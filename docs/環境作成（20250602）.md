今回構築した Toppage の開発・本番環境まわりのポイントをまとめます。
特に Vercel（静的サイト＋サーバーレス関数）、Supabase（DB）、GitHub Pages（静的ホスティング）の
役割や関係性について触れています。

# 1. プロジェクト構成と各サービスの役割

toppage/
├─ api/                     ← Vercel Functions（サーバーレス API）
│   ├─ get-count.ts         ← “views”／“likes”を返すエンドポイント
│   ├─ track.ts             ← “views”を +1 するエンドポイント
│   └─ like.ts              ← “likes”を +1 するエンドポイント
│
├─ public/                  ← 静的資産（favicon、など）
│   └─ index.html
│
├─ src/                     ← フロントエンド（Vue + TypeScript + Vite）
│   ├─ main.ts
│   ├─ App.vue
│   ├─ data/
│   │   └─ games.ts
│   └─ components/
│       ├─ GameList.vue
│       ├─ GameItem.vue
│       └─ GameStats.vue   ← “views”/“likes” を表示・リアルタイム更新する部分
│
├─ vite.config.ts           ← Vite の設定（開発サーバのポート、HTML をアセット扱いにする etc.）
├─ package.json
├─ tsconfig.json
├─ .env.development         ← ローカル開発用環境変数
└─ vercel.json              ← Vercel デプロイ設定

## api/ 配下
サーバーレス関数として Vercel 上にデプロイされる TypeScript ファイル群。
 get-count.ts：/api/get-count?game=XXX&field=views|likes → 指定ゲームのカウントを返す

 track.ts：/api/track?game=XXX → “views” カラムを +1 し、新しい値を返す

 like.ts：/api/like?game=XXX → “likes” カラムを +1 し、新しい値を返す
## src/ 配下（Vue＋TypeScript＋Vite）
 GameStats.vue：API を呼び出し、各ゲームの view/like カウントを取得して表示。

 GameList.vue：ゲーム一覧を表示し、各アイテムに対して GameStats を埋め込む。

 GameItem.vue：各ゲームへのリンク（Play/Demo/Repo）を表示し、クリック時に GA4 のトラッキングを行う。
## vercel.json
 "builds"：静的ビルド（Vite→dist/）とサーバーレス関数（api/**/*.ts）を指定。

 "routes"：/api/* は api/ 内の TS ファイルにルーティングし、それ以外は index.html（SPA）を返す。

 .env.development / .env.production

 SUPABASE_URL / SUPABASE_KEY：Supabase プロジェクトへの接続情報

 VITE_API_BASE （ローカル開発時のみ必要）：http://localhost:3000 を指定し、フロントから開発中のサーバーレス API を呼べるようにする

# 2. Supabase（DB）設定
## テーブル定義
テーブル名：page_views

カラム：

 game (text) ― ゲームを一意に表す文字列（例："tetris-vue"）

 views (integer, default=0) ― 閲覧数

 likes (integer, default=0) ― いいね数

game カラムに対してユニーク制約を張り（PRIMARY KEY または UNIQUE）、
upsert({ game, views }) などが効くようにする

## API からの操作

 get-count.ts では .select(field).eq('game', game).single() を実行 → 件がなければ 0 を返す

 track.ts では .select('views') → 既存数 +1 → .upsert({ game, views: newVal })

 like.ts では .select('likes') → 既存数 +1 → .upsert({ game, likes: newVal })

 エラーコード PGRST116（PostgREST の “no rows” コード）は「まだこのゲームの行がない」状態を表すため、0 扱いにする

## CORS 設定

Vercel Functions 側で明示的にヘッダーをセット：

res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS');
res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
これにより、フロント側（別ポート／別オリジン）からも安全に呼び出せる

環境変数の取り扱い

ローカル開発用 (.env.development)

SUPABASE_URL=…
SUPABASE_KEY=…
VITE_API_BASE=http://localhost:3000
PORT=5173          ← ViteDevServer のポート（任意）
Vercel にアップしたあとの本番用

Vercel ダッシュボードの「Environment Variables」にて

SUPABASE_URL  = https://<your-project>.supabase.co
SUPABASE_KEY  = <プロジェクトのサービスロールキーなど>
フロント（Vite 部分）は環境変数 VITE_API_BASE を設定しない（Vercel Dev/本番ともに同じホストで /api がそのまま切り替わるため）

# 3. Vite（ローカル開発）の構成
vite.config.ts のポイント

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  base: '/',
  plugins: [vue()],
  resolve: {
    alias: { '@': path.resolve(__dirname, 'src') },
  },
  server: {
    // Vercel Dev が自動的に渡す「PORT」環境変数があればそれを優先し、
    // 無ければ 5173 を使うという設定
    port: Number(process.env.PORT) || 5173,
    strictPort: true,
    // proxy: { … } は不要
    // → Vercel Dev モードでは、/api/* への呼び出しが自動的に Functions サーバー (3000) に渡る
  },
  // HTML をアセットとして扱うようにすると、import-analysis エラーを防ぎつつ
  // index.html をきちんと返せるようになる
  assetsInclude: ['**/*.html'],
})
assetsInclude: ['**/*.html']

Vite が index.html を「自前で返す」際にエラーにならずにビルドできるようにする設定

server.port / strictPort

ローカル開発中：PORT=5173

npx vercel dev を使った場合：PORT=3000 （Vercel Dev が自動的に設定する）

ローカル起動コマンド

通常は npm run dev → http://localhost:5173

Vercel Dev モードであれば npx vercel dev を実行 →

Vite が PORT=3000 を受け取り http://localhost:3000 で起動し、
/api/* へのリクエストは自動でローカル Functions サーバー（同じ 3000）にルーティングされる

つまり「ターミナル１本だけ」でフロントも API も同時に立ち上がる

フロント側コード（GameStats.vue など）での API 呼び出し例

const API_BASE = import.meta.env.VITE_API_BASE || '';

async function fetchCount(field: 'views' | 'likes'): Promise<number> {
  const url = `${API_BASE}/api/get-count`;
  const res = await axios.get(url, { params: { game: gameId, field } });
  return res.data.count;
}
ローカル環境：VITE_API_BASE = http://localhost:3000 を .env.development でセットしておくと、

fetchCount('views') = http://localhost:3000/api/get-count?game=...&field=views

Vercel Dev／本番：VITE_API_BASE は定義していない or 空文字なので、

相対パス /api/get-count?game=... がそのまま呼ばれる → Vercel 側の Functions サーバーに届く

# 4. Vercel へのデプロイ
vercel.json の内容

{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": { "distDir": "dist" }
    },
    {
      "src": "api/**/*.ts",
      "use": "@vercel/node"
    }
  ],
  "routes": [
    { "src": "/api/(.*)", "dest": "/api/$1.ts" },
    { "handle": "filesystem" },
    { "src": "/(.*)",     "dest": "/index.html" }
  ]
}
"builds"

package.json をトリガーに npm run build → dist/ フォルダを静的サイトとしてホスティング

api/**/*.ts を Vercel Node ランタイムでデプロイ（サーバーレス関数として）

"routes"

/api/* → 関数（api/get-count.ts など）へ振る

それ以外 → dist/index.html（SPA の entry）を返す

本番環境での挙動

フロントは https://<your-project>.vercel.app/ を開くと、即座に dist/index.html が返る

/api/track などにアクセスすると、ビルド済みのサーバーレス関数 (.ts → JavaScript にトランスパイル済み) が実行され、
Supabase へクエリを投げて結果を返す

環境変数 は Vercel ダッシュボードで SUPABASE_URL / SUPABASE_KEY を設定しておく必要がある

CORS は各 API 関数内でヘッダをセットしてあるので、フロントと同じオリジンで呼ばれても問題なく動作する

# 5. GitHub Pages との関係
GitHub Pages はあくまで「静的ファイルを置くだけ」のホスティングです。

npm run build:gh → vite build --base /toppage/ して dist/ を生成

npm run deploy → gh-pages -d dist でリポジトリの gh-pages ブランチに dist/ をデプロイ

こうして https://<username>.github.io/toppage/ で静的なフロント画面（HTML/CSS/JS）だけを公開できる

今回のプロジェクトでは

フロントのみを GitHub Pages に置いて、API は別サーバ（例：Vercel／Netlify Functions など）を叩くパターン

すべてを GitHub Pages に乗せることはできない（API 部分がサーバレス関数だから）

フルスタックで Vercel にデプロイ

静的フロント (dist/) もサーバーレス API (api/) もまとめて Vercel 上に置く → GitHub Pages は不要

両方を用意する場合

フロントを GitHub Pages にホストし、環境変数（VITE_API_BASE）で「API の URL」を Vercel の関数ドメインに向ける

そうすればフロントは GitHub Pages（例：https://user.github.io/toppage/）に置きつつ、API は Vercel で叩く構成も取れる

# 6. まとめ：環境構築のポイント
Supabase テーブル準備

テーブル名：page_views

カラム：game (text, unique), views (integer), likes (integer)

Row が存在しない場面では error.code === 'PGRST116' を「0 値扱い」にする

ローカル開発環境

.env.development に Supabase 接続情報と VITE_API_BASE=http://localhost:3000 を置く

vite.config.ts で

server: {
  port: Number(process.env.PORT) || 5173,
  strictPort: true,
},
assetsInclude: ['**/*.html'],
GameStats.vue などでは import.meta.env.VITE_API_BASE を先頭に付けて API を呼び出す

npx vercel dev → PORT=3000 が渡るので、

フロント（Vite）は http://localhost:3000 で起動

/api/* は自動的に同じプロセスのサーバーレス関数にルーティング

Vercel 本番環境

vercel.json を用意し、

"src": "package.json" → @vercel/static-build"（npm run build → dist/）

"src": "api/**/*.ts" → @vercel/node（サーバーレス関数）

routes 設定で /api/* を TS 関数に振り、その他は SPA の index.html

Vercel ダッシュボード上で SUPABASE_URL・SUPABASE_KEY を Environment Variables に登録

本番ではフロントから相対パスの /api/get-count を呼ぶだけで自動的に Functions が叩かれる

GitHub Pages との切り分け

GitHub Pages は純粋に「静的ファイルのみ」をホストする

フロント専用として使うなら、VITE_API_BASE を本番 Vercel の URL に書き換えておく

Vercel は静的フロントもサーバーレス API も含めた「フルスタックデプロイ」向き

ポイントおさらい
フロント開発（Vue + Vite）

.env.development で VITE_API_BASE=http://localhost:3000

npm run dev または npx vercel dev でローカルサーバー起動

vite.config.ts でポート（process.env.PORT || 5173）を決め、HTML をアセット扱いに

サーバーレス API（Vercel Functions）

api/*.ts に CORS ヘッダーを追加

Supabase クライアントを createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY) で初期化

get-count.ts, track.ts, like.ts といった形で upsert / select を実装

本番デプロイ

GitHub リモートにプッシュ後、Vercel が自動でビルド＆デプロイ

Vercel 上で環境変数を登録すれば、本番で動く

フロントと API を同じドメイン配下にまとめられるので、CORS 設定は本番では最小限で済む

GitHub Pages の場合

“フロントだけ” を静的にホスティングしたいときは npm run build:gh → gh-pages

その際は、本番用に .env.production で

VITE_API_BASE=https://<your-vercel-domain>
を設定し、本番では Vercel の API を叩くようにすれば併用できる

以上が、今回の Toppage プロジェクトで行った

ローカル開発の流れ

Supabase テーブル設計と API 実装

Vercel デプロイ設定

GitHub Pages との使い分け
の全体像になります。これで「どこをどう設定すればよいのか」「なぜその設定が必要なのか」がひと通り把握できるかと思います。何か追加の疑問があればお気軽にお知らせください！